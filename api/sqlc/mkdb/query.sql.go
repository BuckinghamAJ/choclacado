// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package mkdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const associatePostTag = `-- name: AssociatePostTag :exec
INSERT INTO posts_tags (post_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssociatePostTagParams struct {
	PostID int32
	TagID  int32
}

func (q *Queries) AssociatePostTag(ctx context.Context, arg AssociatePostTagParams) error {
	_, err := q.db.Exec(ctx, associatePostTag, arg.PostID, arg.TagID)
	return err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
  title, description, accountPosted, resource, url, content
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, title, description, accountposted, createdate, updatedate, resource, url, content
`

type CreatePostParams struct {
	Title         string
	Description   string
	Accountposted string
	Resource      int32
	Url           pgtype.Text
	Content       pgtype.Text
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.Title,
		arg.Description,
		arg.Accountposted,
		arg.Resource,
		arg.Url,
		arg.Content,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Accountposted,
		&i.Createdate,
		&i.Updatedate,
		&i.Resource,
		&i.Url,
		&i.Content,
	)
	return i, err
}

const createResourceType = `-- name: CreateResourceType :one
INSERT INTO resource_type (value)
VALUES ($1)
RETURNING id, value
`

func (q *Queries) CreateResourceType(ctx context.Context, value string) (ResourceType, error) {
	row := q.db.QueryRow(ctx, createResourceType, value)
	var i ResourceType
	err := row.Scan(&i.ID, &i.Value)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (value)
VALUES ($1)
RETURNING id, value
`

func (q *Queries) CreateTag(ctx context.Context, value string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, value)
	var i Tag
	err := row.Scan(&i.ID, &i.Value)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT p.id, p.title, p.description, p.accountposted, p.createdate, p.updatedate, p.resource, p.url, p.content, array_agg(t.value) as tags, rt.value as resourceType
FROM posts p
LEFT JOIN posts_tags pt ON p.id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.id
LEFT JOIN resource_type rt ON rt.id = p.resource
ORDER BY p.createDate DESC
`

type GetAllPostsRow struct {
	ID            int32
	Title         string
	Description   string
	Accountposted string
	Createdate    pgtype.Timestamptz
	Updatedate    pgtype.Timestamptz
	Resource      int32
	Url           pgtype.Text
	Content       pgtype.Text
	Tags          interface{}
	Resourcetype  pgtype.Text
}

func (q *Queries) GetAllPosts(ctx context.Context) ([]GetAllPostsRow, error) {
	rows, err := q.db.Query(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPostsRow
	for rows.Next() {
		var i GetAllPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
			&i.Tags,
			&i.Resourcetype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateTag = `-- name: GetOrCreateTag :one
INSERT INTO tags (value)
VALUES ($1)
ON CONFLICT DO NOTHING
RETURNING id, value
`

func (q *Queries) GetOrCreateTag(ctx context.Context, value string) (Tag, error) {
	row := q.db.QueryRow(ctx, getOrCreateTag, value)
	var i Tag
	err := row.Scan(&i.ID, &i.Value)
	return i, err
}

const getPost = `-- name: GetPost :one
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPost(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Accountposted,
		&i.Createdate,
		&i.Updatedate,
		&i.Resource,
		&i.Url,
		&i.Content,
	)
	return i, err
}

const getPostTags = `-- name: GetPostTags :many
SELECT t.id, t.value FROM tags t
JOIN posts_tags pt ON t.id = pt.tag_id
WHERE pt.post_id = $1
`

func (q *Queries) GetPostTags(ctx context.Context, postID int32) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getPostTags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceType = `-- name: GetResourceType :one
SELECT id, value FROM resource_type
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetResourceType(ctx context.Context, id int32) (ResourceType, error) {
	row := q.db.QueryRow(ctx, getResourceType, id)
	var i ResourceType
	err := row.Scan(&i.ID, &i.Value)
	return i, err
}

const getSinglePost = `-- name: GetSinglePost :many
SELECT p.id, p.title, p.description, p.accountposted, p.createdate, p.updatedate, p.resource, p.url, p.content, array_agg(t.value) as tags, rt.value as resourceType
FROM posts p
LEFT JOIN posts_tags pt ON p.id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.id
LEFT JOIN resource_type rt ON rt.id = p.resource
WHERE p.id = $1
GROUP BY p.id
`

type GetSinglePostRow struct {
	ID            int32
	Title         string
	Description   string
	Accountposted string
	Createdate    pgtype.Timestamptz
	Updatedate    pgtype.Timestamptz
	Resource      int32
	Url           pgtype.Text
	Content       pgtype.Text
	Tags          interface{}
	Resourcetype  pgtype.Text
}

func (q *Queries) GetSinglePost(ctx context.Context, id int32) ([]GetSinglePostRow, error) {
	rows, err := q.db.Query(ctx, getSinglePost, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSinglePostRow
	for rows.Next() {
		var i GetSinglePostRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
			&i.Tags,
			&i.Resourcetype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByValue = `-- name: GetTagByValue :one
SELECT id, value FROM tags
WHERE value = $1 LIMIT 1
`

func (q *Queries) GetTagByValue(ctx context.Context, value string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByValue, value)
	var i Tag
	err := row.Scan(&i.ID, &i.Value)
	return i, err
}

const listPosts = `-- name: ListPosts :many
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
ORDER BY createDate DESC
`

func (q *Queries) ListPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByAccount = `-- name: ListPostsByAccount :many
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
WHERE accountPosted = $1
ORDER BY createDate DESC
`

func (q *Queries) ListPostsByAccount(ctx context.Context, accountposted string) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPostsByAccount, accountposted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByMultipleTags = `-- name: ListPostsByMultipleTags :many
SELECT p.id, p.title, p.description, p.accountposted, p.createdate, p.updatedate, p.resource, p.url, p.content, COUNT(pt.tag_id) as tag_match_count
FROM posts p
JOIN posts_tags pt ON p.id = pt.post_id
JOIN tags t ON pt.tag_id = t.id
WHERE t.value = ANY($1::text[])
GROUP BY p.id
HAVING COUNT(pt.tag_id) = $2
ORDER BY p.createDate DESC
`

type ListPostsByMultipleTagsParams struct {
	Column1 []string
	TagID   int32
}

type ListPostsByMultipleTagsRow struct {
	ID            int32
	Title         string
	Description   string
	Accountposted string
	Createdate    pgtype.Timestamptz
	Updatedate    pgtype.Timestamptz
	Resource      int32
	Url           pgtype.Text
	Content       pgtype.Text
	TagMatchCount int64
}

func (q *Queries) ListPostsByMultipleTags(ctx context.Context, arg ListPostsByMultipleTagsParams) ([]ListPostsByMultipleTagsRow, error) {
	rows, err := q.db.Query(ctx, listPostsByMultipleTags, arg.Column1, arg.TagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByMultipleTagsRow
	for rows.Next() {
		var i ListPostsByMultipleTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
			&i.TagMatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByResourceType = `-- name: ListPostsByResourceType :many
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
WHERE resource = $1
ORDER BY createDate DESC
`

func (q *Queries) ListPostsByResourceType(ctx context.Context, resource int32) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPostsByResourceType, resource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByTag = `-- name: ListPostsByTag :many
SELECT p.id, p.title, p.description, p.accountposted, p.createdate, p.updatedate, p.resource, p.url, p.content FROM posts p
JOIN posts_tags pt ON p.id = pt.post_id
JOIN tags t ON pt.tag_id = t.id
WHERE t.value = $1
ORDER BY p.createDate DESC
`

func (q *Queries) ListPostsByTag(ctx context.Context, value string) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPostsByTag, value)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByUser = `-- name: ListPostsByUser :many
SELECT p.id, p.title, p.description, p.accountposted, p.createdate, p.updatedate, p.resource, p.url, p.content FROM posts p
JOIN account a ON p.accountPosted = a.id
WHERE a."userId" = $1
ORDER BY p.createDate DESC
`

func (q *Queries) ListPostsByUser(ctx context.Context, userid string) ([]Post, error) {
	rows, err := q.db.Query(ctx, listPostsByUser, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceTypes = `-- name: ListResourceTypes :many
SELECT id, value FROM resource_type
ORDER BY value
`

func (q *Queries) ListResourceTypes(ctx context.Context) ([]ResourceType, error) {
	rows, err := q.db.Query(ctx, listResourceTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ResourceType
	for rows.Next() {
		var i ResourceType
		if err := rows.Scan(&i.ID, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostTag = `-- name: RemovePostTag :exec
DELETE FROM posts_tags
WHERE post_id = $1 AND tag_id = $2
`

type RemovePostTagParams struct {
	PostID int32
	TagID  int32
}

func (q *Queries) RemovePostTag(ctx context.Context, arg RemovePostTagParams) error {
	_, err := q.db.Exec(ctx, removePostTag, arg.PostID, arg.TagID)
	return err
}

const searchPostsByDescription = `-- name: SearchPostsByDescription :many
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
WHERE description ILIKE '%' || $1 || '%'
ORDER BY createDate DESC
`

func (q *Queries) SearchPostsByDescription(ctx context.Context, dollar_1 pgtype.Text) ([]Post, error) {
	rows, err := q.db.Query(ctx, searchPostsByDescription, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPostsByTitle = `-- name: SearchPostsByTitle :many
SELECT id, title, description, accountposted, createdate, updatedate, resource, url, content FROM posts
WHERE title ILIKE '%' || $1 || '%'
ORDER BY createDate DESC
`

func (q *Queries) SearchPostsByTitle(ctx context.Context, dollar_1 pgtype.Text) ([]Post, error) {
	rows, err := q.db.Query(ctx, searchPostsByTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Accountposted,
			&i.Createdate,
			&i.Updatedate,
			&i.Resource,
			&i.Url,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :exec
UPDATE posts
SET title = $2,
    description = $3,
    resource = $4,
    url = $5,
    content = $6,
    updateDate = NOW()
WHERE id = $1
`

type UpdatePostParams struct {
	ID          int32
	Title       string
	Description string
	Resource    int32
	Url         pgtype.Text
	Content     pgtype.Text
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.db.Exec(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Resource,
		arg.Url,
		arg.Content,
	)
	return err
}
